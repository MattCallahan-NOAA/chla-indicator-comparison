---
title: "Chlorophyll indicator comparison"
author: "Matt Callahan"
date: "6/15/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidync)
library(tidyverse)
library(lubridate)
library(sf)
library(httr)
library(flextable)
library(marmap)
```




## MODIS
MODIS data were downloaded from a google folder where Jordan stored them from previous efforts https://drive.google.com/drive/u/1/folders/1mhwQ70mjLrkiQYiQ2oNHx08Q7IlL8Q3-

```{r}
#EBS
mod_ebs<-readRDS("Data/MODIS/merged_8day_2003_2021_EBS.RDS")
#GOA

```

## OC-CCI
**Download 8 day OC-CCI data**
If we import MODIS into AKFIN we will probably import daily chlorophyll and calculate 8 day values, but for now I will download the 8 day product. Run once.
```{r}
#Download one day of grid east of the dateline
#extent 47, 70, -130, -180
   download.file(url = "https://coastwatch.pfeg.noaa.gov/erddap/griddap/pmlEsaCCI50OceanColorDaily.nc?chlor_a%5B(2021-06-01T00:00:00Z)%5D%5B(69):(47)%5D%5B(-179.99):(-130)%5D&.draw=surface&.vars=longitude%7Clatitude%7Cchlor_a&.colorBar=%7C%7C%7C%7C%7C&.bgColor=0xffccccff", method = "libcurl", mode="wb",destfile = "Data/OCCCI/occci_06012021.nc")
```

**convert OCC to usable format**
Once file is downloaded, the following code converts to a data frame
```{r}
#import as data file
tidy_chl<-function(file) {
  tidync(file) %>% 
  hyper_tibble()%>% 
  mutate(date=as_datetime(time),
                  chlorophyll=round(chlor_a,3))
  
}

#rounding fields if needed
 #        lonc=as.numeric(ifelse(longitude<0, #ifelse statement keeps +- lons the same length
  #                              substr(longitude,1,8),
  #                              substr(longitude,1,7))), 
   #      latc=as.numeric(substr(latitude,1,6)), 
         

occ<-tidy_chl("Data/OCCCI/occci_06012021.nc")

```

**Create OCC lookup grid**
```{r}
#Make lookup table similar to process for VIIRS

#Identify max and min values
max(occ$latitude);min(occ$latitude)
max(occ$longitude);min(occ$longitude)

#Create string of 20 lowest longitudes to test matching the lookup table
lon<-as.numeric(substr(head(sort(unique(occ$longitude)), 21), 1, 9))
#Create string to match with longitudes for lookup table
lonlkp<-as.numeric(#convert to number
  substr(#cut to four decimals
    #create sequence
    c(seq(from=-179.97916666666666667, to=-179.1458, by=0.0416666666666667)),1,9))
#compare
lon
lonlkp
lon-lonlkp

#now for full 
#create new vectors with 4 decimal places
lon_lkp<-as.numeric(substr(c(seq(from=-179.97916666666666667, to=-129.9791, by=0.0416666666666667)), 1, 9)) #east
#           seq(from=167.0063, to=179.9813, by=0.0375)) #not adding west of dateline for now

#does this still work for the end of the vector?
lont<-as.numeric(substr(tail(sort(unique(occ$longitude)), 15), 1, 9))

lonlkpt<-tail(lon_lkp,15)
lonlkpt
lont
lont-lonlkpt

#OK, that was annoying... but I think that works. 

lat_lkp<-as.numeric(substr(seq(from=46.97916666666666667, to=69.0209, by=0.0416666666666667), 1, 7))

#compare with latitude vector
lath<-as.numeric(substr(head(sort(unique(occ$latitude)), 15), 1, 7))
latt<-as.numeric(substr(tail(sort(unique(occ$latitude)), 15), 1, 7))

lath-head(lat_lkp,15)#start works
latt-tail(lat_lkp,15)#lkp extends higher than data, I'm just going to run it...

#create grid
occ_grid<-expand.grid(lon_lkp, lat_lkp)%>%
  rename(latitude=Var2, longitude=Var1)

#join chla data with lookup table.   
test_join<-occ%>%
  mutate(latitude=as.numeric(substr(latitude, 1, 7)),
         longitude=as.numeric(substr(longitude, 1, 9)))%>%
  inner_join(occ_grid, by=c("longitude"="longitude", "latitude"="latitude"))         

#Fuck yeah!
```

**Add marine area fields**
We need the same fields as in the crw sst spatial lookup table. 

*statefed* Flags if the location is in "state", "fed" or "intl" (international) waters.    

*stat_area* ADF&G statistical area (there are 1758 of these total) <http://www.adfg.alaska.gov/index.cfm?adfg=fishingCommercialByFishery.statmaps>    

*nmfsarea*  NMFS management areas <https://www.fisheries.noaa.gov/alaska/sustainable-fisheries/alaska-fisheries-figures-maps-boundaries-regulatory-areas-and-zones>   

    

*Ecosystem*  From the AK_MES shapefile created for the ESRs. The shapefiles has four areas but we omitted Arctic.    

*Ecosystem_sub*  The AK_MES shapefile did not include all of the ESR subregions so I created them. NBS / SEBS are split at 60. EGOA and WGOA are split at 144. The eastern and western Aleutians are split at -177 and positive 177, with the central region in between.  

*bsierp_name* and *bsierp_id*  Name and ID of BSIERP area.

*crab areas* Bering Sea crab management areas: *nbs_crab*, *bs_king*, and *bs_tanner*.

*depth*  This is the GEBCO bathymetry dataset as pulled by the marmap package using resolution=1. Data have been filtered for depths<0  

We will use ADFG for our spatial extent. 1) they cover the rest of the ecosystem, NMFS, and BSIERP regions except the arctic, 2) The CRW lookup table uses the same extent, and 3) Spatial aggregations by stat area may become an importan seconday product as this data is gap-rich. 

**Download sptial data**
Spatial Data were loaded from two esri file geodatabases prepared by Brett Holycross at PSMFC. The Alaska Marine Management Areas layers contain ADFG, NMFS, and BSIERP regions, that have long been static. Ecosystem and Ecosystem subareas reflect the updated boundaries requested by Ecosystem Status Report Authors in 2022. The Bering Sea Crab area layers were created in consultation with Erin Fedewa (NMFS).

```{r}
#add eval=FALSE before knitting
#load spatial data
#marine management areas
Management <- st_read(dsn="Data/GIS/Alaska_Marine_Management_Areas.gdb", layer="Alaska_Marine_Areas_dd")
unique(Management$Area_Type)
ADFG<-Management%>%filter(Area_Type=="ADFG Stat Area")%>%
  dplyr::select(STAT_AREA, WATERS_COD, Shape_Length, Shape_Area, Shape)
NMFS<-Management%>%filter(Area_Type=="NMFS Reporting Area")%>%
  dplyr::select(NMFS_REP_AREA, Shape_Length, Shape_Area, Shape)
ESR<-Management%>%filter(Area_Type=="Ecosystem Subarea")%>%
  dplyr::select(Ecosystem_Subarea, Shape_Length, Shape_Area, Shape)
LME<-Management%>%filter(Area_Type=="Ecosystem Area")%>%
  dplyr::select(Ecosystem_Area, Shape_Length, Shape_Area, Shape)
BSIERP<-Management%>%filter(Area_Type=="BSIERP Region")%>%
  dplyr::select(BSIERP_ID, BSIERP_Region_Name, Shape_Length, Shape_Area, Shape)
#crab areas
nbs_crab <- st_read(dsn="Data/GIS/AK_Crab_Management_Areas.gdb", layer="NBS_Crab_dd")
bs_tanner_crab <- st_read(dsn="Data/GIS/AK_Crab_Management_Areas.gdb", layer="BS_Tanner_Crab_dd")
bs_king_crab <- st_read(dsn="Data/GIS/AK_Crab_Management_Areas.gdb", layer="BS_King_Crab_dd")

```
**Add spatial components to lookup table**
```{r, eval=FALSE}
#Turn off spherical geometry
sf::sf_use_s2(FALSE)

#point in polygon to add regional information to grid
#convert grid to spatial object
grid <- occ_grid%>%
  mutate(LAT=latitude, LON=longitude)%>%
  st_as_sf(coords = c('LON', 'LAT'), crs = 4326, agr = 'constant')

#ADFG
grid<-st_join(grid, ADFG, join = st_within)

#plot
ggplot()+
  geom_sf(data=grid, aes(color=STAT_AREA))

#limit to points with a stat area
#brings from >1 million to <400k
grid<-grid%>%
  filter(STAT_AREA>0)

#NMFS
grid<-grid%>%
  st_join(NMFS, join = st_within)

#way slow. Save output 
saveRDS(grid, "Data/OCCCI/grid_adfg_nmfs.RDS")

#Ecosystem Area
grid<-grid%>%
  st_join(LME, join = st_within)
saveRDS(grid, "Data/OCCCI/occ_adfg_nmfs_lme.RDS")

#Ecosystem subarea
grid<-grid%>%
  st_join(ESR, join = st_within)
saveRDS(grid, "Data/OCCCI/occ_adfg_nmfs_lme_esr.RDS")

#BSIERP
grid<-grid%>%
  st_join(BSIERP, join = st_within)

#NBS crab
grid<-grid%>%
  st_join(nbs_crab, join = st_within)

#BS King crab
grid<-grid%>%
  st_join(bs_king_crab, join = st_within)

#BS Tanner crab
grid<-grid%>%
  st_join(bs_tanner_crab, join = st_within)
saveRDS(grid, "Data/OCCCI/grid_all_boundaries.RDS")

#filter out all of that shape.x.1 etc fields
grid1<-grid%>%
  dplyr::select(latitude, longitude, STAT_AREA, WATERS_COD, NMFS_REP_AREA, Ecosystem_Area, Ecosystem_Subarea, BSIERP_ID, BSIERP_Region_Name, NBS_CRAB, BS_KING, BS_TANNER, Shape_Length.x, Shape_Area.x, geometry)

```

**3.4 Add depth**
We use NOAA bathymetry from the marmap package to attribute depth to points
```{r}
#Also load marmap
r.ak <- getNOAA.bathy(lon1=-180,lon2=-129,lat1=47.5,lat2=71, resolution=1)
#Positive longitudes
#r.ak_w <- getNOAA.bathy(lon1=167,lon2=180,lat1=47.5,lat2=71, resolution=1)
#converting to a raster
r.ak2 <- marmap::as.raster( r.ak)
#r.ak3 <- marmap::as.raster( r.ak_w)

#r.ak4<-raster::merge(r.ak2, r.ak3)


#merge combined raster and remove positive depths
grid2<-grid1%>%mutate(depth=round(raster::extract(r.ak2,cbind(longitude,latitude),method="bilinear"),0))  %>% filter(depth<=0) 
###QA

summary(grid2$depth)


#plot
ggplot()+
  geom_tile(data=grid2, aes(x=longitude, y=latitude, fill=depth, color=depth))

```

**4) Save table as a data frame and export**

```{r, eval=FALSE}
#remove spatial geometry fields
occ_grid<-grid2%>%data.frame()%>%dplyr::select(!c(Shape_Length.x, Shape_Area.x, geometry))
#export
write.csv(occ_grid, "Data/OCCCI/occ_chl_spatial_lookup.csv")
saveRDS(occ_grid, "Data/OCCCI/occ_chl_spatial_lookup.RDS")
```


**Download entire time series**
First test with one year
```{r}
#change timeout option
options(timeout=600)
#Download 2021
#extent 47, 70, -130, -180
   download.file(url = "https://coastwatch.pfeg.noaa.gov/erddap/griddap/pmlEsaCCI50OceanColorDaily.nc?chlor_a%5B(2021-03-01T00:00:00Z):(2021-06-30T00:00:00Z)%5D%5B(69):(47)%5D%5B(-179.99):(-130)%5D&.draw=surface&.vars=longitude%7Clatitude%7Cchlor_a&.colorBar=%7C%7C%7C%7C%7C&.bgColor=0xffccccff", method = "libcurl", mode="wb",destfile = "Data/OCCCI/occ_2021.nc")

   #examine
   occ21<-tidy_chl("Data/OCCCI/occ_2021.nc")
 unique(occ21$date)  
 #DOH I used daily for this whole thing. Hopefully the eight day ones are the same extent...
 
 #let's try 8 day   
  download.file(url = "https://coastwatch.pfeg.noaa.gov/erddap/griddap/pmlEsaCCI50OceanColor8Day.nc?chlor_a%5B(2021-03-01T00:00:00Z):(2021-06-30T00:00:00Z)%5D%5B(69):(47)%5D%5B(-179.99):(-130)%5D&.draw=surface&.vars=longitude%7Clatitude%7Cchlor_a&.colorBar=%7C%7C%7C%7C%7C&.bgColor=0xffccccff", method = "libcurl", mode="wb",destfile = "Data/OCCCI/occ8_2021.nc")
 
  #examine
   occ21<-tidy_chl("Data/OCCCI/occ8_2021.nc")
 unique(occ21$date)  
```

```{r}
#download the rest of the years
options(timeout=6000)
#myyear <- 1998:2020
myyear <- 2003:2020
for(i in myyear){
  file_name <- paste0("Data/OCCCI/occ8_",i,".nc")
  download.file(url = paste0("https://coastwatch.pfeg.noaa.gov/erddap/griddap/pmlEsaCCI50OceanColor8Day.nc?chlor_a%5B(",
                             i,"-03-01T00:00:00Z):(", i,"-07-07T00:00:00Z)%5D%5B(69):(47)%5D%5B(-179.99):(-130)%5D&.draw=surface&.vars=longitude%7Clatitude%7Cchlor_a&.colorBar=%7C%7C%7C%7C%7C&.bgColor=0xffccccff"),
                method = "libcurl", mode="wb",destfile = file_name)
}

#done
file_name <- paste0("Data/chlorophyll/chl_2020_through_07232020.nc")

download.file(url = paste0("https://coastwatch.pfeg.noaa.gov/erddap/griddap/erdMH1chla8day.nc?chlorophyll[(
                           2020-01-05T00:00:00Z):1:(last)][(68.75):1:(46.)][(-179.9792):1:(-129)]"),
              method = "libcurl", mode="wb",destfile = file_name)
```


## VIIRS
We are currently importing viirs into AKFIN, allowing us to process indicators in the database.

## ESP indicators
These indicators were requested by stock assessment authors. Each indicator is a single value for each year.

**Previous ESP Indicator descriptions**
```{r}
#check which indicators were used
data <- httr::content(httr::GET("https://apex.psmfc.org/akfin/data_marts/akmp/esp_indicators?"),
                      type = "application/json"
) %>%
  dplyr::bind_rows()%>%
  filter(grepl('Chlorophylla', INDICATOR_NAME))

#all ours?
unique(data$CONTACT) #yes

#Descriptions
data%>%group_by(INDICATOR_NAME)%>%
  summarise(descritption=unique(PRODUCT_DESCRIPTION),
            submission_year=unique(SUBMISSION_YEAR))%>%
   flextable()%>%
  theme_box()
  write.csv("esp_chlorophyll_indicators.csv")

  #csv to send to Kalei to confirm active indicators
  data%>%group_by(INDICATOR_NAME)%>%
  summarise(descritption=unique(PRODUCT_DESCRIPTION),
            submission_year=unique(SUBMISSION_YEAR))%>%
  write.csv("esp_chlorophyll_indicators.csv")
```
**AMJ_Chlorophylla_Biomass_SEBS_Satellite**

**Spring_Chlorophylla_Biomass_EGOA_Satellite**

**Spring_Chlorophylla_Biomass_SEBS_Inner_Shelf_Satellite**

**Spring_Chlorophylla_Biomass_SEBS_Satellite**

**Spring_Chlorophylla_Biomass_SMBKC_Satellite**

**Spring_Chlorophylla_Biomass_WCGOA_Satellite**

**Spring_Chlorophylla_Peak_EGOA_Satellite**

**Spring_Chlorophylla_Peak_SEBS_Satellite**

**Spring_Chlorophylla_Peak_WCGOA_Satellite**

**Recalculate ESP indices**
```{r}
mod_ebs<-readRDS("Data/MODIS/merged_8day_2003_2021_EBS.RDS")
```